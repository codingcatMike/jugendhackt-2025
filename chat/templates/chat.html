{% extends "base.html" %}
{% block title %}Chat mit - {{ chat.user2.username }}{% endblock title %}
{% load static %}
{% block content %}
<link rel="stylesheet" type="text/css" href="{% static 'css/chat.css' %}">    

<div id="coinCount" style="display:none;">
 {% with user.profile_set.first as profile %}
    {% if profile %}
        {{ profile.coins }}
  {% else %}
    0
  {% endif %}
  {% endwith %}
</div>
<div class="main-layout">
  <div id="searchResults" style="overflow-y: auto; max-height: 100%; background-color: #f5f5f5"></div>
  <div class="chat-list "  id="chatList ">
    <h3>Chats</h3>
    {% for c in user_chats %}
    <div class="chat-item {% if c.id == chat.id %}active{% endif %}"
        data-chat-id="{{ c.id }}"
        {% if c.last_msg_time %}data-last-activity="{{ c.last_msg_time|date:'Y-m-d H:i:s' }}"{% endif %}>
      <span>{% if user == c.user1 %}{{ c.user2.username }}{% else %}{{ c.user1.username }}{% endif %}</span>
      <small>
        {% if c.last_msg_time %}
          {{ c.last_msg_time|date:"d.m.Y H:i" }}
        {% else %}
          Kein Verlauf
        {% endif %}
      </small>
    </div>
    {% empty %}
      <p style="padding:10px;">Keine Chats vorhanden.</p>
    {% endfor %}
    <button id="startChatBtn" onclick="window.location.href='{% url 'start_chat' %}'" style="margin:10px; padding:8px 12px; border:none; border-radius:8px; background:#9cbeff; color:white; cursor:pointer;">Neuen Chat starten</button>
  </div>

  <div class="chat-area">
    <div class="header-row">
      <div>
        <button class="keygen-btn" id="generateKeysBtn">ðŸ”‘ Generate / Upload Keys</button>
        <div class="log-note">Tipp: (Re)generate oder upload keys wenn EntschlÃ¼sselung fehlschlÃ¤gt.</div>
        <input 
    type="text" 
    id="messageSearch" 
    placeholder="Search messages..." 
    style="width: 100%; padding: 8px; margin-bottom: 10px;"
>



      </div>
      {% if chat.activated == False %}
      {% if chat.user2 == request.user %}
        <div style="color:green; font-weight:600;">Dieser Chat ist noch nicht aktiviert! Bitte bestÃ¤tige den Chat, um Nachrichten zu senden.</div>
        <button onclick="window.location.href='{% url 'activate_chat' chat.id %}'" style="margin-left:10px; padding:6px 10px; border:none; border-radius:8px; background:#9cbeff; color:white; cursor:pointer;">Chat bestÃ¤tigen</button>
        {% else %}
      <div style="color:red; font-weight:600;">Dieser Chat ist noch nicht aktiviert! Bitte warte auf die BestÃ¤tigung des anderen Nutzers.</div>
      {% endif %}
      {% endif %}
      <div class="coin-box">
        <div>Deine Coins:</div>
        <div id="coinDisplay" class="coin-count">0</div>
      </div>
    </div>

    <div class="messages-scroll" id="chatContainer">
      {% for message in messages %}
      <div class="message {% if message.sender == user %}message-right{% else %}message-left{% endif %}"
          data-encrypted="{{ message.content|safe }}"
          id="msg-{{ message.id }}"
          data-key-sender="{{ message.encrypted_key_sender|default:'' }}"
          data-key-recipient="{{ message.encrypted_key_recipient|default:'' }}"
          data-iv="{{ message.iv|default:'' }}"
          {% if message.media %}data-media="{{ message.media.url }}"{% endif %}>
          {% if message.media %}
              <img src="{{ message.media.url }}" width="120" loading="lazy">
          {% else %}
              <strong>{{ message.sender.username }}:</strong>
              <span>{{ message.content }}</span>
          {% endif %}

          <em>({{ message.timestamp }})</em>
      </div>
      {% endfor %}
    </div>

    <div class="chat-input">
      <input type="text" id="messageInput" placeholder="Schreibe eine Nachricht...">
      <div class="file-upload-wrapper">
        <label for="mediaInput" class="file-upload-btn">ðŸ“Ž Bild auswÃ¤hlen</label>
        <input type="file" id="mediaInput" accept="image/*">
        <span class="file-name" id="fileName"></span>
      </div>
      <button id="gifShopBtn">ðŸª™ GIFs</button>
      <button id="sendBtn" title="Senden">
        <img src="{% static 'images/flyer.png' %}" alt="Send" style=" width:40px; height:40px;">
      </button>
      <div class="gif-menu" id="gifMenu"></div>
      <span class="error-msg" id="errorMsg"></span>
    </div>
  </div>
</div>

<script>
window.chatConfig = {
    chatId: "{{ chat.id }}",
    username: "{{ request.user.username }}",
    recipientId: "{% if chat.user1 == request.user %}{{ chat.user2.id }}{% else %}{{ chat.user1.id }}{% endif %}"
};
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
    console.log("DOM loaded. Initializing chat JS...");

    const chatContainer = document.getElementById("chatContainer");
    const messageInput = document.getElementById("messageInput");
    const mediaInput = document.getElementById("mediaInput");
    const sendBtn = document.getElementById("sendBtn");
    const gifBtn = document.getElementById("gifShopBtn");
    const gifMenu = document.getElementById("gifMenu");
    const fileName = document.getElementById("fileName");
    const errorMsg = document.getElementById("errorMsg");
    const coinCountEl = document.getElementById("coinCount");
    let userCoins = coinCountEl ? parseInt(coinCountEl.textContent || "0") : 0;
    const coinDisplay = document.getElementById("coinDisplay");
    coinDisplay.textContent = userCoins;

    // ------------------- LAZY LOADING VARIABLES -------------------
    let lazyPage = 1;
    let lazyLoading = false;
    let lazyHasMore = true;

    // ------------------- CHAT LIST CLICK -------------------
    const chatItems = document.querySelectorAll(".chat-item");
    chatItems.forEach(item => {
        item.addEventListener("click", () => {
            const chatId = item.dataset.chatId;
            if (chatId) {
                window.location.href = `/chat/${chatId}/`;
            }
        });
    });

    const chatId = window.chatConfig.chatId;
    const username = window.chatConfig.username;
    const recipientId = window.chatConfig.recipientId;

    const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
    const chatSocket = new WebSocket(`${wsScheme}://${window.location.host}/ws/chat/${chatId}/`);

    function scrollToBottom() {
        if (chatContainer) chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    setTimeout(scrollToBottom, 100);

    chatSocket.onopen = () => console.log("WebSocket connected");
    chatSocket.onclose = () => console.log("WebSocket closed");

    // ------------------- WS ONMESSAGE -------------------
    chatSocket.onmessage = async function(e) {
        try {
            const data = JSON.parse(e.data);
            console.log("WS message received:", data);

            if (data.error) {
                errorMsg.textContent = data.error;
                return;
            }

            if (typeof data.coins !== "undefined") {
                userCoins = parseInt(data.coins);
                coinDisplay.textContent = userCoins;
                if (coinCountEl) coinCountEl.textContent = userCoins;
                return;
            }

            if (!data.sender) return;

            const msgEl = document.createElement("div");
            const isMe = data.sender === username;
            msgEl.className = "message " + (isMe ? "message-right" : "message-left");

            if (data.media) {
                msgEl.innerHTML = `<img src="${data.media}" width="120" loading="lazy"><em>${data.sender}</em> <em>(${data.timestamp})</em>`;
            } else {
              let decryptedText = "[Fehler beim EntschlÃ¼sseln]";

              const keyForMe = isMe
                  ? data.encrypted_key_sender
                  : data.encrypted_key_recipient;

              if (keyForMe && data.iv && data.encrypted_message) {
                  try {
                      decryptedText = await decryptMessageAES(
                          data.encrypted_message,
                          keyForMe,
                          data.iv
                      );
                  } catch (err) {
                      console.error("Decrypt error for WS message:", err);
                      decryptedText = "[Fehler beim EntschlÃ¼sseln]";
                  }
              }

                msgEl.dataset.encrypted = data.encrypted_message || "";
                msgEl.dataset.keySender = data.encrypted_key_sender || "";
                msgEl.dataset.keyRecipient = data.encrypted_key_recipient || "";
                msgEl.dataset.iv = data.iv || "";

                msgEl.innerHTML = `<strong>${data.sender}:</strong> <span>${decryptedText}</span> <em>(${data.timestamp})</em>`;
            }

            chatContainer.appendChild(msgEl);
            scrollToBottom();
            errorMsg.textContent = "";
        } catch (err) {
            console.error("WS onmessage parse error:", err);
        }
    };

    // ------------------- ENCRYPTION HELPERS -------------------
    function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = "";
        bytes.forEach(b => binary += String.fromCharCode(b));
        return window.btoa(binary);
    }

    function base64ToArrayBuffer(b64) {
        const binary = window.atob(b64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        return bytes.buffer;
    }

    async function importPublicKey(base64) {
        return crypto.subtle.importKey(
            "spki",
            base64ToArrayBuffer(base64),
            { name: "RSA-OAEP", hash: "SHA-256" },
            true,
            ["encrypt"]
        );
    }

    async function importPrivateKey(base64) {
        return crypto.subtle.importKey(
            "pkcs8",
            base64ToArrayBuffer(base64),
            { name: "RSA-OAEP", hash: "SHA-256" },
            true,
            ["decrypt"]
        );
    }

    async function encryptMessageAES(message) {
        const aesKey = await crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt"]);
        const encoder = new TextEncoder();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, encoder.encode(message));
        const rawAesKey = await crypto.subtle.exportKey("raw", aesKey);
        return { ciphertext, rawAesKey, iv };
    }

    async function encryptAESKeyRSA(rawAesKey, recipientPublicKey) {
        return crypto.subtle.encrypt({ name: "RSA-OAEP" }, recipientPublicKey, rawAesKey);
    }

    async function decryptMessageAES(cipherTextB64, encryptedKeyB64, ivB64) {
        try {
            const privateKeyB64 = localStorage.getItem("privateKey_" + username);
            if (!privateKeyB64) throw new Error("Private key not found in localStorage");
            const privateKey = await importPrivateKey(privateKeyB64);
            const encryptedKey = base64ToArrayBuffer(encryptedKeyB64);
            const aesKeyRaw = await crypto.subtle.decrypt({ name: "RSA-OAEP" }, privateKey, encryptedKey);
            const aesKey = await crypto.subtle.importKey("raw", aesKeyRaw, { name: "AES-GCM" }, false, ["decrypt"]);
            const iv = base64ToArrayBuffer(ivB64);
            const cipherBytes = base64ToArrayBuffer(cipherTextB64);
            const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, aesKey, cipherBytes);
            return new TextDecoder().decode(decrypted);
        } catch (err) {
            console.error("Decrypt error:", err);
            return "[Fehler beim EntschlÃ¼sseln]";
        }
    }

    // ------------------- LOAD RECIPIENT PUBLIC KEY -------------------
    async function getRecipientPublicKey() {
        try {
            const res = await fetch(`/api/get-public-key/${recipientId}/`);
            if (!res.ok) throw new Error("Fehler beim Laden der Ã¶ffentlichen SchlÃ¼ssel");
            return await res.text();
        } catch (err) {
            console.error(err);
            errorMsg.textContent = "Kann den Ã¶ffentlichen SchlÃ¼ssel des EmpfÃ¤ngers nicht laden.";
            return null;
        }
    }

    // ------------------- SEND MESSAGE -------------------
    async function sendMessage(message, recipientPublicKeyB64, mediaData = null, isGif = false, price = 0) {
        try {
            let payload = {};
            if (mediaData) {
                payload = { media: mediaData, media_type: isGif ? "gif" : "image", price };
            } else {
                const { ciphertext, rawAesKey, iv } = await encryptMessageAES(message);
                const recipientKey = await importPublicKey(recipientPublicKeyB64);
                const senderPublicKeyB64 = localStorage.getItem("publicKey_" + username);
                const senderKey = await importPublicKey(senderPublicKeyB64);
                const encryptedKeyRecipient = await encryptAESKeyRSA(rawAesKey, recipientKey);
                const encryptedKeySender = await encryptAESKeyRSA(rawAesKey, senderKey);

                payload = {
                    encrypted_message: arrayBufferToBase64(ciphertext),
                    encrypted_key_recipient: arrayBufferToBase64(encryptedKeyRecipient),
                    encrypted_key_sender: arrayBufferToBase64(encryptedKeySender),
                    iv: arrayBufferToBase64(iv)
                };
            }

            chatSocket.send(JSON.stringify(payload));
        } catch (err) {
            console.error("Encryption error:", err);
            errorMsg.textContent = "Fehler bei der VerschlÃ¼sselung!";
        }
    }

    // ------------------- SEND BUTTON -------------------
    sendBtn.addEventListener("click", async () => {
        const msg = messageInput.value.trim();
        const mediaFile = mediaInput.files[0];
        const recipientPublicKeyB64 = await getRecipientPublicKey();
        if (!recipientPublicKeyB64) return;
        if (!msg && !mediaFile) return;
        errorMsg.textContent = "";

        if (mediaFile) {
            const reader = new FileReader();
            reader.onload = async function() {
                await sendMessage(null, recipientPublicKeyB64, reader.result, false, 0);
                scrollToBottom();
            };
            reader.readAsDataURL(mediaFile);
        } else {
            await sendMessage(msg, recipientPublicKeyB64);
            scrollToBottom();
        }

        messageInput.value = "";
        mediaInput.value = "";
        fileName.textContent = "";
    });

    messageInput.addEventListener("keyup", e => {
        if (e.key === "Enter") sendBtn.click();
    });

    // ------------------- GIF SHOP -------------------
    gifBtn.addEventListener("click", async () => {
        if (gifMenu.style.display === "block") {
            gifMenu.style.display = "none";
            return;
        }
        try {
            const res = await fetch("/api/gifs/");
            if (!res.ok) throw new Error("Fehler beim Laden der GIF-Liste");
            const gifs = await res.json();
            gifMenu.innerHTML = gifs.map(gif => `
                <div class="gif-item" data-url="${gif.url}" data-price="${gif.price}">
                    <img src="${gif.url}" alt="${gif.name}" loading="lazy">
                    <span class="gif-price">ðŸª™ ${gif.price}</span>
                </div>
            `).join("");
            gifMenu.style.display = "block";

            gifMenu.querySelectorAll(".gif-item").forEach(item => {
                item.addEventListener("click", async () => {
                    const price = parseInt(item.dataset.price);
                    const url = item.dataset.url;
                    if (userCoins < price) {
                        errorMsg.textContent = "Nicht genÃ¼gend Coins!";
                        return;
                    }
                    errorMsg.textContent = "Sende GIF...";
                    gifMenu.style.display = "none";
                    try {
                        const blobRes = await fetch(url);
                        if (!blobRes.ok) throw new Error("Fehler beim Laden des GIFs");
                        const blob = await blobRes.blob();
                        const reader = new FileReader();
                        reader.onload = async function() {
                            const recipientPublicKeyB64 = await getRecipientPublicKey();
                            if (!recipientPublicKeyB64) return;
                            await sendMessage(null, recipientPublicKeyB64, reader.result, true, price);
                            errorMsg.textContent = "";
                            scrollToBottom();
                        };
                        reader.readAsDataURL(blob);
                    } catch (err) {
                        console.error(err);
                        errorMsg.textContent = "Fehler beim Laden der GIF-Datei!";
                    }
                });
            });
        } catch (err) {
            console.error(err);
            errorMsg.textContent = "Fehler beim Laden der GIFs.";
        }
    });

    mediaInput.addEventListener("change", () => {
        fileName.textContent = mediaInput.files.length > 0 ? mediaInput.files[0].name : "";
    });

    // ------------------- KEY GENERATION -------------------
    const generateKeysBtn = document.getElementById("generateKeysBtn");
    generateKeysBtn.addEventListener("click", () => generateAndUploadKeys());

    async function generateAndUploadKeys() {
        const uploadUrl = "/upload_public_key/";
        try {
            const keyPair = await crypto.subtle.generateKey({
                name: "RSA-OAEP",
                modulusLength: 2048,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: "SHA-256"
            }, true, ["encrypt", "decrypt"]);

            const publicKeyB64 = arrayBufferToBase64(await crypto.subtle.exportKey("spki", keyPair.publicKey));
            const privateKeyB64 = arrayBufferToBase64(await crypto.subtle.exportKey("pkcs8", keyPair.privateKey));

            localStorage.setItem("privateKey_" + username, privateKeyB64);
            localStorage.setItem("publicKey_" + username, publicKeyB64);

            const res = await fetch(uploadUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": getCSRFToken()
                },
                body: JSON.stringify({
                    username,
                    chat_id: chatId,
                    public_key: publicKeyB64,
                    algorithm: "RSA-OAEP-2048-SHA256"
                })
            });

            if (!res.ok) {
                const text = await res.text();
                throw new Error(text);
            }

            alert("Keys generated & uploaded âœ“");
        } catch (err) {
            console.error(err);
            alert("Fehler beim Key-Upload: " + err.message);
        }
    }

    function getCSRFToken() {
        const cookieValue = document.cookie.split("; ").find(row => row.startsWith("csrftoken="));
        return cookieValue ? cookieValue.split("=")[1] : "";
    }

    // ------------------- DECRYPT OLD MESSAGES -------------------
    async function decryptOldMessages() {
        console.log("Decrypting old messages...");
        const messages = Array.from(chatContainer.querySelectorAll(".message")).reverse();
        for (const msgDiv of messages) {
            const msgEl = msgDiv.querySelector("span");
            const isMe = msgDiv.classList.contains("message-right");
            const encryptedMessage = msgDiv.dataset.encrypted;
            const iv = msgDiv.dataset.iv;
            const keyForMe = isMe ? msgDiv.dataset.keySender : msgDiv.dataset.keyRecipient;
            const mediaUrl = msgDiv.dataset.media;

            // Skip media or messages without span
            if (mediaUrl || !msgEl) continue;

            if (!encryptedMessage || !iv || !keyForMe) {
                msgEl.textContent = "[Fehler beim EntschlÃ¼sseln]";
                continue;
            }

            try {
                msgEl.textContent = await decryptMessageAES(encryptedMessage, keyForMe, iv);
            } catch (err) {
                console.error("Decrypt error for old message:", err);
                msgEl.textContent = "[Fehler beim EntschlÃ¼sseln]";
            }
        }
    }

    decryptOldMessages();

    // ------------------- LAZY LOAD OLDER MESSAGES -------------------
    async function loadOlderMessages() {
        if (lazyLoading || !lazyHasMore) return;

        lazyLoading = true;
        lazyPage++;

        const oldHeight = chatContainer.scrollHeight;

        try {
            const res = await fetch(`/chat/${chatConfig.chatId}/load/?page=${lazyPage}`);
            if (!res.ok) throw new Error("Load failed");

            const data = await res.json();
            lazyHasMore = data.has_more;

            data.messages.reverse().forEach(msg => {
            const el = document.createElement("div");
            el.id = "msg-" + msg.id; // NEW
            el.className = "message " + (msg.is_me ? "message-right" : "message-left");


                if (msg.media) {
                    el.innerHTML = `
                        <img src="${msg.media}" width="120" loading="lazy">
                        <em>(${msg.timestamp})</em>
                    `;
                } else {
                    el.dataset.encrypted = msg.encrypted_message;
                    el.dataset.keySender = msg.encrypted_key_sender;
                    el.dataset.keyRecipient = msg.encrypted_key_recipient;
                    el.dataset.iv = msg.iv;

                    el.innerHTML = `
                        <strong>${msg.sender}:</strong>
                        <span>[decrypting...]</span>
                        <em>(${msg.timestamp})</em>
                    `;
                }

                chatContainer.prepend(el);
            });

            await decryptOldMessages();

            chatContainer.scrollTop = chatContainer.scrollHeight - oldHeight;

        } catch (err) {
            console.error("Lazy load error:", err);
        }

        lazyLoading = false;
    }

    chatContainer.addEventListener("scroll", () => {
        if (chatContainer.scrollTop < 50) {
            loadOlderMessages();
        }
    });
    async function searchMessages(query) {
    const resultsContainer = document.getElementById("searchResults");

    resultsContainer.innerHTML = "Searching...";

    let page = 1;
    let hasMore = true;
    let matches = [];
    const { chatId } = window.chatConfig;


    while (hasMore) {
        const res = await fetch(`/chat/${window.chatConfig.chatId}/load/?page=${page}`);

        if (!res.ok) break;

        const data = await res.json();
        for (const msg of data.messages) {
            let decryptedText = "[Decryption error]";
            try {
                const keyForMe = msg.is_me ? msg.encrypted_key_sender : msg.encrypted_key_recipient;
                if (keyForMe && msg.iv && msg.encrypted_message) {
                    decryptedText = await decryptMessageAES(msg.encrypted_message, keyForMe, msg.iv);
                }
            } catch (e) {
                console.error("Decrypt error:", e);
            }

            if (decryptedText.toLowerCase().includes(query.toLowerCase())) {
              matches.push({
                  id: msg.id,
                  sender: msg.sender,
                  text: decryptedText,
                  timestamp: msg.timestamp,
                  media: msg.media
              });

            }
        }

        hasMore = data.has_more;
        page++;
    }

      if (matches.length === 0) {
          resultsContainer.innerHTML = "<p>No messages found.</p>";
      } else {
          resultsContainer.innerHTML = matches.map(m => {
              let mediaHtml = m.media ? '<br><img src="' + m.media + '" width="100" loading="lazy">' : '';
              return '<div class="search-result" data-msg-id="' + m.id + '" style="padding:5px; border-bottom:1px solid #ccc; cursor:pointer;">' +
                  '<strong>' + m.sender + '</strong>: ' + m.text +
                  '<br><small>' + m.timestamp + '</small>' +
                  mediaHtml +
              '</div>';
          }).join('');


          // Attach click listeners dynamically
          resultsContainer.querySelectorAll(".search-result").forEach(el => {
              el.addEventListener("click", () => scrollToMessage(el.dataset.msgId));
          });
      }



    }


document.getElementById("messageSearch").addEventListener("input", e => {
    const query = e.target.value.trim();
    if (query.length > 0) {
        searchMessages(query);
    } else {
        document.getElementById("searchResults").innerHTML = "";
    }
});


async function scrollToMessage(msgId) {
    let msgEl = document.getElementById("msg-" + msgId);
    const maxAttempts = 50;
    let attempts = 0;

    // Try lazy-loading older messages if needed
    while (!msgEl && lazyHasMore && attempts < maxAttempts) {
        await loadOlderMessages();  
        msgEl = document.getElementById("msg-" + msgId);
        attempts++;
    }

    if (msgEl) {
        // Scroll within chatContainer only
        const container = chatContainer; // already defined earlier
        const containerTop = container.getBoundingClientRect().top;
        const containerScrollTop = container.scrollTop;
        const msgTop = msgEl.getBoundingClientRect().top;
        const offset = msgTop - containerTop;
        const targetScroll = containerScrollTop + offset - container.clientHeight / 2 + msgEl.clientHeight / 2;

        container.scrollTo({
            top: targetScroll,
            behavior: "smooth"
        });

        // Temporary highlight
        msgEl.style.backgroundColor = "#ffff99";
        setTimeout(() => msgEl.style.backgroundColor = "", 2000);
    } else {
        alert("Nachricht konnte nicht gefunden werden (zu alt oder Fehler beim Laden).");
    }
}


});



</script>

{% endblock content %}
